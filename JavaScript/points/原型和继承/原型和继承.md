# 原型和继承

如今 class 语法已经被纳入 ES6 规范中了，那么我们还必要学习原型和继承吗？
答案当然是肯定的，因为 class 语法不过是 Function 的语法糖，我们不光要知其然，还要知其所以然
我们知道，JavaScript 中的继承都是基于原型的，那么下面我们来看看什么是原型。

## \_\_proto\_\_ 和 prototype

如果你看过其他讲原型的文章，基本都有这样一句话，在 JavaScript 中的继承都是基于原型的。我们不妨更准确的说，所有的的继承都是基于对象的，包括函数，因为函数也是对象。
每一个函数都有一个 prototype 属性，做原型，早些年的前端规范是比较混乱的，各个浏览器都为对象设置了一个私有属性 \_\_proto\_\_，也有人把它叫做隐式原型，这个 \_\_proto\_\_ 指向它的构造函数的原型对象（prototype）。从 ECMAScript 6 开始，\_\_proto\_\_ 被规范成了 \[[Prototype]]，而 [[Prototype]] 可以通过 Object.getPrototypeOf() 和 Object.setPrototypeOf() 访问器来访问。

```js
const obj = {}
console.log(obj.__proto__ === Object.prototype) // true
console.log(obj.__proto__ === Object.getPrototypeOf(obj)) // true
```

## 原型链

### constructor

上面我们说到了每一个原型对象 prototype 上面都有 constructor 属性，这个属性指向了构造函数本身

```js
function Person (name) {
  this.name = name
}
const p = new Person('mxx')
console.log(Person.prototype.constructor === Person) // true
const p1 = new Person.prototype.constructor('mxx')
console.log(p1.name) // mxx
```


