# 原型和继承

如今 class 语法已经被纳入 ES6 规范中了，那么我们还必要学习原型和继承吗？
答案当然是肯定的，因为 class 语法不过是 Function 的语法糖，我们不光要知其然，还要知其所以然
我们知道，JavaScript 中的继承都是基于原型的，那么下面我们来看看什么是原型。

## \_\_proto\_\_ 和 prototype

如果你看过其他讲原型的文章，基本都有这样一句话，在 JavaScript 中的继承都是基于原型的。我们不妨更准确的说，所有的的继承都是基于对象的，包括函数，因为函数也是对象。
每一个函数都有一个 prototype 属性，做原型，早些年的前端规范是比较混乱的，各个浏览器都为对象设置了一个私有属性 \_\_proto\_\_，也有人把它叫做隐式原型，这个 \_\_proto\_\_ 指向它的构造函数的原型对象（prototype）。从 ECMAScript 6 开始，\_\_proto\_\_ 被规范成了 \[[Prototype]]，而 [[Prototype]] 可以通过 Object.getPrototypeOf() 和 Object.setPrototypeOf() 访问器来访问。

```js
const obj = {}
console.log(obj.__proto__ === Object.prototype) // true
console.log(obj.__proto__ === Object.getPrototypeOf(obj)) // true
```

## 原型链

### constructor

上面我们说到了每一个函数都有原型对象 prototype，而 prototype 上面都有 constructor 属性，这个属性指向了构造函数本身

```js
function Person (name) {
  this.name = name
}
const p = new Person('mxx')
console.log(Person.prototype.constructor === Person) // true
const p1 = new Person.prototype.constructor('mxx')
console.log(p1.name) // mxx
```

### 什么是原型链？

看到这里，我们都知道了实例对象的私有属性 \_\_proto\_\_ 是指向其构造函数的 prototype，而 prototype 其实也是一个对象，我们叫做原型对象，那么它也会有 \_\_proto\_\_ 这个私有属性，也指向了它的构造函数。当我们访问对象的属性时，就会通过原型对象一层层向上找，知道找到 Object.prototype，这个查找的链路就是原型链，直到一个对象的原型为 null，而 null 没有原型，这个就是原型链的终点，这个终点一般为 Object.prototype.\__proto__。
我们再来看一个例子

```js
class Person {
  constructor(name) {
    this.name = name
  }
}

class Child extends Person {
  constructor(name) {
    super(name)
  }
}

const child = new Child('mxx')
console.log(child.name) // mxx
console.log(child.toString.call(1)) // [object Number]
```

第一个 console 打印出了 mxx，这是因为 Child 类继承了 Person 类，所以当我们实例 Child 类的时候，就能够通过原型访问到 name 属性。
那么第二个 console 打印出了 [object Number]，虽然 Person 和 Child 都没有 toString 这个方法，但是根据原型链总能找到 Object.prototype，所以就能找到 Object 原型上的 toString 方法。

## 原型链的检测

