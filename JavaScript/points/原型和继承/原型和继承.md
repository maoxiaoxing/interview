# 原型和继承

如今 class 语法已经被纳入 ES6 规范中了，那么我们还必要学习原型和继承吗？
答案当然是肯定的，因为 class 语法不过是 Function 的语法糖，我们不光要知其然，还要知其所以然
我们知道，JavaScript 中的继承都是基于原型的，那么下面我们来看看什么是原型。

## \_\_proto\_\_ 和 prototype

如果你看过其他讲原型的文章，基本都有这样一句话，在 JavaScript 中的继承都是基于原型的。我们不妨更准确的说，所有的的继承都是基于对象的，包括函数，因为函数也是对象。
每一个函数都有一个 prototype 属性，做原型，早些年的前端规范是比较混乱的，各个浏览器都为对象设置了一个私有属性 \_\_proto\_\_，也有人把它叫做隐式原型，这个 \_\_proto\_\_ 指向它的构造函数的原型对象（prototype）。从 ECMAScript 6 开始，\_\_proto\_\_ 被规范成了 \[[Prototype]]，而 [[Prototype]] 可以通过 Object.getPrototypeOf() 和 Object.setPrototypeOf() 访问器来访问。

```js
const obj = {}
console.log(obj.__proto__ === Object.prototype) // true
console.log(obj.__proto__ === Object.getPrototypeOf(obj)) // true
```

## 原型链

### constructor

上面我们说到了每一个函数都有原型对象 prototype，而 prototype 上面都有 constructor 属性，这个属性指向了构造函数本身

```js
function Person (name) {
  this.name = name
}
const p = new Person('mxx')
console.log(Person.prototype.constructor === Person) // true
const p1 = new Person.prototype.constructor('mxx')
console.log(p1.name) // mxx
```

### 什么是原型链？

看到这里，我们都知道了实例对象的私有属性 \_\_proto\_\_ 是指向其构造函数的 prototype，而 prototype 其实也是一个对象，我们叫做原型对象，那么它也会有 \_\_proto\_\_ 这个私有属性，也指向了它的构造函数。当我们访问对象的属性时，就会通过原型对象一层层向上找，知道找到 Object.prototype，这个查找的链路就是原型链，直到一个对象的原型为 null，而 null 没有原型，这个就是原型链的终点，这个终点一般为 Object.prototype.\__proto__。
我们再来看一个例子

```js
class Person {
  constructor(name) {
    this.name = name
  }
}

class Child extends Person {
  constructor(name) {
    super(name)
  }
}

const child = new Child('mxx')
console.log(child.name) // mxx
console.log(child.toString.call(1)) // [object Number]
```

第一个 console 打印出了 mxx，这是因为 Child 类继承了 Person 类，所以当我们实例 Child 类的时候，就能够通过原型访问到 name 属性。
那么第二个 console 打印出了 [object Number]，虽然 Person 和 Child 都没有 toString 这个方法，但是根据原型链总能找到 Object.prototype，所以就能找到 Object 原型上的 toString 方法。

## 原型链的检测

### instanceof

说到原型链的检测，很多有过了解的人肯定第一时间想到的就是 instanceof，instanceof 在 MDN 的描述如下
> instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。

我们看几个例子

```js
// 1
console.log(child instanceof Child)
// 2
console.log(child instanceof Person)
// 3
console.log(child instanceof Object)
```

这三个的答案都为 true
这三个结果也很好理解：
1. child 是由 Child 类实例出来的，那么 Child.prototype 肯定在 child 的原型链上
2. Child 是继承自 Person，那么结果2也毫无疑问是对的
3. 很多人可能有疑问的是第3个结果，在 JavaScript 中万物皆对象，所以所有的函数基本都是由 Object 类派生出来的，所以 Object.prototype 也在 child 对象的原型链上

下面的例子可以更好印证第3点

```js
const date = new Date()
const reg = new RegExp()
const str = new String()

console.log(date instanceof Object) // true
console.log(str instanceof Object) // true
console.log(reg instanceof Object) // true
```

很多人为了去应付面试，选择将上面的例子都背下来，其实没有必要，我们看完 instanceof 的一个简单版的 polyfill，上面的现象都很好解释了

```js
const my_instanceof = function(left, right) {
  let left_proto = left.__proto__
  const right_prototype = right.prototype

  while(true) {
    if (left_proto === null) return false
    if (left_proto === right_prototype) return true

    left_proto = left_proto.__proto__
  }
}
```

可以看到 my_instanceof 内部会先查找实例对象的隐式原型 \__proto__，如果和右侧的构造函数匹配就返回 true，如果没有就再找原型对象的隐式原型，那么最终一定会找到 Object.prototype，如果和右侧的构造函数的原型对象还不相等，那么还会找到 Object.prototype.\__proto__，这个值一般都会为 null，这就是原型链的终点，所以结束匹配，返回 false。

